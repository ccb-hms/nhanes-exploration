---
title: "Examples of workflows enabled by docker"
output: github_document
always_allow_html: true
---


```{r, include = FALSE}
knitr::opts_chunk$set(comment = "",
                      fig.path = "figures/",
                      out.width = "100%",
                      fig.width = 12, fig.height = 8,
                      dev = "svglite", dev.args = list(pointsize = 12),
                      cache = TRUE,
                      warning = TRUE, error = FALSE,
                      cache.path = "./knitr-cache/dockereg/")
options(width = 100)
```


## Potential topics to include:

- Reproducibility - [Cobalt paper](https://ccb-hms.github.io/phonto/vignettes/cobalt_paper.html)

- Better [search facilities](https://ccb-hms.github.io/phonto/vignettes/search-tables.html): e.g., tables, variables

- Combining data across cycles

- Special codes in numeric variables

- Variables that are potentially skipped

- Consistency checks:

	- Variables appearing in multiple tables

	- Change in units


## Combining data across cycles


To illustrate the process of combining data across cycles, we
combine the demographic data table from all cycles. NHANES table names
typically have a suffix; the suffixes `_A`, `_B`, `_C`,and so on
generally correspond to NHANES cycle years from 1999-2000, 2001-2002,
2003-2004, etc. However, it is important to highlight that not every
table strictly adheres to this naming convention. For instance, while
`DEMO_B` and `DEMO_C` are associated with the 2001-2002 and 2003-2004
cycles, respectively, the corresponding table for the 1999-2000 cycle
is named 'DEMO', without the `_A` suffix. While this pattern holds for
most tables, certain tables such as `SSAFB_A` and `SSANA_A` from the
1999-2000 cycle do include the `_A` suffix. To assist users in
navigating these variations, the `nhanesA` package includes the
`nhanesSearchTableNames()` function, which allows users to easily
locate all table names containing a specific string, thus simplifying
the process of identifying relevant table names.

```{r alldemo}
library(nhanesA)
demo_all <- nhanesSearchTableNames("DEMO")
demo_all
```

The last table in this list merits special mention. During the
2019-2020 cycle, data collection was disrupted by the COVID-19
pandemic. Therefore, the partial 2019-2020 data (herein 2019-March
2020 data) were combined with data from the previous cycle (2017-2018)
to create a nationally representative sample covering 2017-March 2020.
These data files have the same basic file name, e.g., `DEMO`, but add
the prefix `P_`. These 'pre-pandemic' files require special handling
and the CDC has provided substantial guidance as well as updated
survey weights.

We can now download all these datasets from the CDC website using the
`nhanes()` function. Note, however, that this process is likely to be
somewhat slow as several files will need to be downloaded.

```{r getalldemo, error = TRUE}
all_demo_data <- sapply(demo_all, nhanes, simplify = FALSE)
object.size(all_demo_data) # ~45 MB
sapply(all_demo_data, dim)
```

The first row in the output above gives the number of participants in
each cycle, and the second row denotes the number of variables in the
corresponding `DEMO` table. We can see that each cycle has around
10,000 participants, who are unique across cycles. Note, however, that
the larger number of participants in the `P_DEMO` dataset is
misleading, because many of these participants are actually from the
previous cycle as described above. We will drop this table before
combining the remaining datasets.

The differing number of variables across cycles indicate that
variables are not measured consistently across cycles. In fact, many
variables included in the `DEMO` table in the first cycle were
subsequently included in other tables, and others have been dropped
altogether or added. We can make a list of the variables that are
common to all `DEMO` tables, and combine the corresponding data
subsets together, as follows.

```{r combinedemo}
all_demo_data <- head(all_demo_data, -1)
common_vars <- lapply(all_demo_data, names) |> Reduce(f = intersect)
common_vars
demo_combined <-
    lapply(all_demo_data, `[`, common_vars) |>
    do.call(what = rbind) |>
    transform(cycle = substring(SDDSRVYR, 8, 17))
dim(demo_combined)
```

The combined dataset can be analysed further using standard tools. For
example, Figure 2 uses the `lattice` package [cite] to
summarize the number of participants by recorded ethnicity and gender
by cycle.

```{r demoplot,fig.width=12, fig.height=7, fig.path = 'images/'}
library("lattice")
demo_combined |>
    xtabs(~ cycle + RIAGENDR + RIDRETH1, data = _) |>
    array2DF() |>
    dotplot(Value ~ cycle | RIAGENDR,
            groups = RIDRETH1,
            layout = c(1, 2), type = "b",
            par.settings = simpleTheme(pch = 16),
            auto.key = list(columns = 3))
```


One must be cautious when combining data across
cycles, because the NHANES data are sometimes inconsistent in
unexpected ways. As a simple example, consider the `DMDEDUC3`
variable, which records education level of children and youth. The
following code illustrates that the values of this variable have
inconsistent capitalization in different cycles.

```{r changes}
xtabs(~ cycle + DMDEDUC3, demo_combined)[, 1:4]
```


## Cross-cycle Consistency checks using variable codebooks

In our experience, inconsistencies such as the change in
capitalization described above occur quite often, and in a variety of
different ways, requiring attention to detail when combining data from
across cycles. These inconsistencies are not necessarily mistakes, as
NHANES questionnaires and variables are often modified from cycle to
cycle. The primary source that must be consulted to identify such
inconsistencies are the per-table documentation, and in particular the
variable codebooks giving details of how each variable is recorded.

The NHANES database contains the variable codebooks for all tables
across all cycles in a single database table called
`Metadata.VariableCodebook`. Once imported into R, this information
can be manipulated in various ways to glean information of interest.

[See <https://ccb-hms.github.io/phonto/vignettes/diagnostics-codebook.html> for more examples.]

```{r}
library("phonto")
dim(all_cb <- nhanesQuery("select * from Metadata.VariableCodebook"))
## dim(all_cb <- metaData("Codebook")) # alt interface
all_cb <- dplyr::filter(all_cb, !startsWith(TableName, "P_")) # skip pre-pandemic tables
```

An analyst would typically be interested in some specific variables
that are relevant to their study. The first step is to identify how
many cycles these variables were recorded in.  To this end, we may
start by examining the number of _tables_ each variable appears in
across all cycles of continuous NHANES.

```{r}
var_freq <- 
    all_cb[c("Variable", "TableName")] |> unique() |>
        xtabs(~ Variable, data = _) |>
        sort(decreasing = TRUE)
table(var_freq)
```

Not surprisingly, many variables appear only once or twice across all
cycles, and for such variables combining data across cycles would not
be interesting. Variables that appear in multiple cycles, but only
once per cycle, may usually be merged as in the `DEMO` example above,
but note that they may appear in different tables. One must be careful
about ensuring that the variable is measuring the same quantity in all
cycles. This is usually true, but not always. For example, the range
of values for the `LBCBHC` variable in different cycles seem to
exhibit some discrepancy.

```{r}
subset(all_cb, Variable == "LBCBHC")[1:5]
```

More useful information about the variables may be obtained from the
`Metadata.QuestionnaireVariables` table in the database, which
contains one row for each variable in each table containing its
description, target group, etc., obtained from the HTML documentation
of NHANES tables.

```{r}
dim(all_var <- phonto::nhanesQuery("select * from Metadata.QuestionnaireVariables"))
## dim(all_var <- metaData("Variables"))
subset(all_var, Variable == "LBCBHC")[1:5]
```

This shows that the unit of measurement was changed from the
2009--2010 cycle, explaining the discrepancy. Without a careful check,
such changes may be overlooked, leading to errors in interpretation.

It is not easy to systematically detect such changes without manual
inspection of variables of interest. One way to shortlist possible
candidate variables are to identify those for whom the `Description`
or `SasLabel` field has changed. Unfortunately, such changes happen
frequently for completely benign reasons, leading to many false
positives.


## Within-cycle consistency

Somewhat more surprisingly, several variables appear
in more tables than there are cycles, which means that they must
appear in multiple tables within the same cycle. The following
variables appear in more than 20 tables.

```{r}
var_freq[ var_freq > 20 ]
```

For such variables, selecting the corresponding subset of `all_cb`
shows all entries in the codebook tables for that variable, across all
tables and cycles. For example,

```{r}
subset(all_cb, Variable == "PHAFSTMN")[1:5]
```

Inspection of this table shows that the `PHAFSTMN` variable was
initially recorded in the `PH` table for the first three cycles, after
which it was recorded in three different tables (`FASTQX`, `GLU`, and
`OGTT`) for several cycles, before being dropped again from the latter
two tables. It is natural to wonder whether all these tables contain
the same data. This can only be verified by comparing the actual data,
which we will not do here, but some hints are provided by the data
counts included in the codebook. For example, for the 2005--2006
cycle, we have

```{r}
subset(all_cb, Variable == "PHAFSTMN" & endsWith(TableName, "_D"))[1:5]
```

More information about the variables may be obtained from the
`Metadata.QuestionnaireVariables` table in the database, which
contains one row for each variable in each table containing its
description, target group, etc., obtained from the HTML documentation
of NHANES tables.

```{r}
dim(all_var <- phonto::nhanesQuery("select * from Metadata.QuestionnaireVariables"))
## dim(all_var <- metaData("Variables"))
subset(all_var, Variable == "PHAFSTMN" & endsWith(TableName, "_D"))[c(1, 2, 4, 5)]
```

While not definitive, this suggests that the `PHAFSTMN` variable
measures the same quantity in all three tables, and the difference in
number of observations may be due to the difference in target age
group.

Even if a preliminary inspection suggests no obvious problems, it is
useful to verify by comparing the actual recorded data. For example,
consider


```{r}
subset(all_var, Variable == "ENQ100" & endsWith(TableName, "_E"))[c(1, 2, 4, 5)]
merge(nhanes("ENX_E")[c("SEQN", "ENQ100")],
      nhanes("SPX_E")[c("SEQN", "ENQ100")],
      by = "SEQN") |>
    xtabs(~ ENQ100.x + ENQ100.y, data =_, addNA = TRUE)
```

Even though most records are consistent, several records with `Yes` or
`No` answers in the `SPX` tables are recorded as `NA` (missing) in the
`ENX` tables.


A more egregious example where the same variable is clearly measuring two different things:

```{r}
subset(all_cb, Variable == "LBXHCT" & endsWith(TableName, "_H"))[1:5]
subset(all_var, Variable == "LBXHCT" & endsWith(TableName, "_H"))[c(1, 2, 3, 4, 5)]
merge(nhanes("CBC_H")[c("SEQN", "LBXHCT")],
      nhanes("COT_H")[c("SEQN", "LBXHCT")],
      by = "SEQN") |> head()
```





```{r, eval=FALSE, echo=FALSE}

## fix cycle, try to find variables that appear in multiple tables, but with different descriptions

cvars <- subset(all_var, endsWith(TableName, "_H"))
dupvars <- with(cvars, Variable[ duplicated(Variable) ]) |> unique()

sapply(dupvars,
       function(v) subset(cvars, Variable == v, select = c(TableName, SasLabel)),
       simplify = FALSE) |> Filter(f = function(d) length(unique(d$SasLabel)) > 1)

# DRDINT
subset(all_cb, Variable == "LBXHCT" & endsWith(TableName, "_H"))[1:5]

subset(all_var, Variable == "LBXHCT")[c(1, 2, 3, 4, 5)]

merge(nhanes("CBC_H")[c("SEQN", "LBXHCT")],
      nhanes("COT_H")[c("SEQN", "LBXHCT")],
      by = "SEQN") |> head()

    ## xtabs(~ ENQ100.x + ENQ100.y, data =_, addNA = TRUE)
    
    ## subset(is.na(ENQ100.x) != is.na(ENQ100.y) | ENQ100.x != ENQ100.y)

    ## with(table(ENQ100.x == ENQ100.y, useNA = "always"))

```





```{r, eval=FALSE, echo=FALSE}

object.size(all_cb) / 1024^2



## First find variables that are considered 'numeric' because they
## have a "range of values" description

numeric_vars <- with(all_cb, unique(Variable[ValueDescription == "Range of Values"]))
dim(numeric_cb <- subset(all_cb, Variable %in% numeric_vars, select = 1:5))

## What are the most common descriptions that appear in the codebooks for these variables?

xtabs(~ ValueDescription, data = numeric_cb) |> sort(decreasing = TRUE) |> head(10)

### Numeric codes for Refused and Don't know

xtabs(~ CodeOrValue, 
      subset(numeric_cb, ValueDescription == "Refused"))

xtabs(~ CodeOrValue, 
      subset(numeric_cb, ValueDescription == "Don't know"))

## So inconsistent, sometimes even for same variable across cycles

subset(numeric_cb, ValueDescription == "Refused" & Variable == "WHD020")

subset(numeric_cb, ValueDescription == "Don't know" & Variable == "ALQ130")


### coarsening





## Selected examples of numeric / categorical ambiguity





## Tables where some items are skipped

tables_with_skipping <- unique(subset(all_cb, !is.na(SkipToItem))$TableName)

## around 30% of tables

length(tables_with_skipping) / length(unique(all_cb$TableName))

## what we really want is to flag variables that might have been
## skipped based on a previous answer

subset(all_cb, TableName == tables_with_skipping[[1]], select = -c(Count, Cumulative))

## question: for a given question, can different answers lead to
## skipping to different places? In any case, given a table, we want
## to first flag all questions that can lead to skipping, and if so, where.




```
