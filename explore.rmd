---
title: "Initial Data Exploration of the `nhanesA` Package"
author: "Deepayan Sarkar"
output: github_document
always_allow_html: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE,
                      comment = "#>",
                      fig.path = "figures/",
                      out.width = "100%",
                      fig.width = 12, fig.height = 5,
                      dev = "svglite", dev.args = list(pointsize = 12),
                      cache = TRUE,
                      cache.path = "./knitr-cache/explore/")
options(width = 100)
library(lattice)
library(kableExtra)
library(DT)
source("R/utilities.R")
```


# Summary of available tables

Data in the `nhanesA` package are stored in a SQL Server database. The 
database can be queried using the (unexported) `.nhanesQuery()` function
or its public wrapper `phonto::nhanesQuery()`.

```{r}
library(nhanesA)
alltables <- nhanesA:::.nhanesQuery("select * from information_schema.tables;")
dim(alltables)
head(alltables) |> kable() |> kable_minimal()
```

There are two versions of each table, the raw table with original codes, and 
translated versions with codes translated into human-readable values. In 
addition, there are some metadata and ontology tables.

```{r}
subset(alltables, !(TABLE_SCHEMA %in% c("Raw", "Translated"))) |> 
  kable() |> kable_minimal()
```

The translated table names can be extracted as follows.

```{r}
trtables <- subset(alltables, TABLE_SCHEMA == "Translated")$TABLE_NAME |> sort()
str(trtables)
```

Many of these start with `P_`; we will skip them (they represent releases made 
during the pandemic, and are inconsistent with previous releases). The remaining 
tables often have suffixes (separated by underscore) that indicate cycle, but 
may also have underscores in the main table name.

```{r}
std_tables <- trtables[!grepl("^P_", trtables)]
std_tables_split <- strsplit(std_tables, "_", fixed = TRUE)
std_tables[ sapply(std_tables_split, length) == 3 ]
```

We will assume that suffixes `_A`, `_B`, ..., `_J` indicate cycles. Then 
valid table names are
```{r}
drop_table_suffix(std_tables) |> table() |> sort(decreasing = TRUE) |> head(100)
```

Some appear only once or twice. These are probably introduced later, and were not 
necessarily continued; for example, the following two tables relate to air quality.
```{r}
std_tables[startsWith(std_tables, "AQQ")]
nhanesCodebook('AQQ_E') |> lapply("[[", "SAS Label:") |> str()
```

# Using metadata tables to obtain table information

Alternatively, we can get information about available tables from the metadata 
tables, although for some reason, these do not include the `P_*` tables. 

```{r}
tableDesc <- nhanesA:::.nhanesQuery("select * from Metadata.QuestionnaireDescriptions")
tableDesc <- within(tableDesc, TableBase <- drop_table_suffix(TableName))
str(tableDesc)
```

We will work with  this from now on. We can summarize this table by table / questionnaire 
descriptions as follows.
```{r}
tableSummary <- 
  xtabs(~ TableBase + Description + DataGroup, tableDesc) |> 
  as.data.frame.table() |> subset(Freq > 0)
head(tableSummary, 20) |> kable() # use datatable() for html_output
```



# Extracting table data

Before trying to analyse any data, we may be interested in knowing whether the 
codebook has changed for a particular table across different cycles. Let's try 
this with the demographic tables.

```{r}
demotables <- get_table_names('DEMO', db = tableDesc)
cb.demo <- lapply(demotables, function(x) names(nhanesCodebook(x)))
str(cb.demo)
```

So the number of recorded variables keep changing. To combine across years, 
we will get all common variables, assuming that their interpretations have 
not changed over cycles.

```{r}
demovars <- get_common_vars(demotables)
str(demovars)
```

We can then merge all versions of a table by restricting to these common 
variables.

```{r}
demo.all <- merge_tables(demotables)
```

Some elementary summaries of the demographic variables:

```{r age_dist_yr}
qqmath(~ RIDAGEYR | SDDSRVYR, demo.all, plot.points = FALSE, distribution = qexp,
       f.value = ppoints(500), pch = ".", cex = 2, as.table = TRUE, grid = TRUE)
```

```{r race_dist_yr}
xtabs(~ SDDSRVYR + RIAGENDR + RIDRETH1, demo.all) |> 
  dotplot(auto.key = list(columns = 2), type = "o", 
          par.settings = simpleTheme(pch = 16))
```


# Combining tables for analysis

Suppose we want to combine demographic data with data from one or more other 
tables to perform some analysis. Let's start by looking at which tables have
been populated in most (at least 8) cycles. The `DEMO` table will not appear in 
this list because it has two slightly different descriptions (with frequencies 
7 and 3).

```{r}
subset(tableSummary, Freq > 7) |> kable() |> kable_minimal()
```

Let's say we now want to combine the tables DEMO, TCHOL (Weight history), 
BPX (Blood pressure) and BMX (Body measurements)


```r
## combine tables, say DEMO, WHQ (Weight history), 
## BPX (Blood pressure) and BMX (Body measurements)

sapply(nhanesCodebook('TCHOL_D'), "[[", "SAS Label:")
sapply(nhanesCodebook('BMX'), "[[", "SAS Label:")
sapply(nhanesCodebook('BPX'), "[[", "SAS Label:")

wtables <- c("DEMO", "WHQ", "BMX", "BPX")

tablist <- lapply(wtables, function(x) merge_tables(get_table_names(x, tableDesc)))
names(tablist) <- wtables

sapply(tablist, nrow) # WHQ has fewer

## Merge by first subsetting to common SEQN values (in same order)

common_id <- Reduce(intersect, lapply(tablist, "[[", "SEQN"))
tablist_common <- lapply(tablist, function(d) d[match(common_id, d$SEQN), ])
dcombined <- Reduce(merge, tablist)

## OK, so we are ready for some anaylsis. But variable names are still 
## incomprehensible without referring to codebook

variableDesc <- nhanesA:::.nhanesQuery("select * from Metadata.QuestionnaireVariables")
## This one includes the P_* tables, which we will exclude (among other reasons, 
## they have not been processed correctly), e.g.,
subset(variableDesc, TableName |> startsWith("P_")) |> head()
## despite https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/P_ACQ.htm#ACD011A having the info

## so
variableDesc <- subset(variableDesc, !startsWith(TableName, "P_"))
str(variableDesc)

uvarDesc <- subset(variableDesc, Variable %in% names(dcombined), select = c(Variable, SasLabel)) |> unique()

## crude search (or use datatable)
subset(uvarDesc, agrepl("weight", SasLabel, ignore.case = TRUE, fixed = TRUE))

xyplot(I(WHD020 * 0.453592) ~ BMXWT, dcombined) # weird - special codes not mapped to NA

nhanesCodebook("BMX")[["BMXWT"]][["BMXWT"]] # no issues - only missing
subset(variableDesc, Variable == "WHD020")
nhanesCodebook("WHQ")[["WHD020"]][["WHD020"]] # 77777 / 99999
nhanesCodebook("WHQ_B")[["WHD020"]][["WHD020"]] # 7777 / 9999

xyplot(I(WHD020 * 0.453592) ~ BMXWT | RIAGENDR, dcombined, subset = WHD020 < 1000, 
       alpha = 0.5, abline = c(0, 1), smooth = "lm", type=c("p", "r"))

xyplot(BMXWT ~  RIDAGEYR | RIAGENDR, dcombined,
       alpha = 0.5, smooth = "lm", type=c("p", "smooth"), col.line = 1)





```





# Miscellaneous oddities

There is a mismatch for tables with base name `SSDFS` (there may be others as 
well).

```{r}
std_tables[startsWith(std_tables, "SSDFS")]
subset(tableDesc, startsWith(TableName, "SSDFS"))[1:5]
```

The `SSDFS_A` table does exist:
```{r}
str(nhanes('SSDFS_A', translated = TRUE))
```
However, even though `SSDFS_G` is a legitimate table, there is no <https://wwwn.cdc.gov/Nchs/Nhanes/2011-2012/SSDFS_A.htm>, and 
the corresponding codebook naturally has no useful information. Where did 
the `SSDFS_A` table come from?


What is the difference between `includelabels = TRUE` and `FALSE`? Neither
version seems to include the SAS labels


```{r}
nhanes('DEMO_G', includelabels = FALSE) |> attributes() |> str()
nhanes('DEMO_G', includelabels = TRUE) |> attributes() |> str()
```



Consider tables whose description contains "cholesterol". 

```{r}
subset(tableSummary, grepl("cholesterol", Description, ignore.case = TRUE)) |> kable()
```

Clearly, similar data  is included in tables with different names, so our 
strategy of merging by table name may be fundamentally flawed. It may be more 
useful to decide on variable names of interest, and obtain all data for those 
variables regardless of which table they are in.


```{r}
subset(tableDesc, TableBase == "TRIGLY")[1:4]
sapply(nhanesCodebook("TRIGLY_E"), "[[", "SAS Label:")
```

So let's search for the `LBDLDL` variable in all tables.

```{r}
varDesc <- nhanesA:::.nhanesQuery("select * from Metadata.QuestionnaireVariables")
subset(varDesc, Variable == "LBDLDL")[c(1, 2, 3)] |> kable()
```


